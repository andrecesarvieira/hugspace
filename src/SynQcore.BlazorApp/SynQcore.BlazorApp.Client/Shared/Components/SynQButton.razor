@namespace SynQcore.BlazorApp.Client.Shared.Components

@*
  Componente de Botão Corporativo SynQcore
  Suporte a diferentes variantes, tamanhos e estados
*@

<button class="@GetButtonClasses()"
        type="@Type"
        disabled="@IsDisabled"
        @onclick="OnClick"
        @onmousedown="OnMouseDown"
        @onclick:stopPropagation="StopPropagation"
        @attributes="AdditionalAttributes">

    @if (IsLoading)
    {
        <span class="synq-spinner" aria-hidden="true"></span>
        <span class="synq-sr-only">Carregando...</span>
    }

    @if (!string.IsNullOrEmpty(Icon) && !IsLoading)
    {
        <span class="synq-btn-icon" aria-hidden="true">@Icon</span>
    }

    @if (!string.IsNullOrEmpty(Text))
    {
        <span>@Text</span>
    }
    else
    {
        @ChildContent
    }

    <!-- Ripple effect overlay -->
    <div class="synq-btn-ripple" @ref="rippleElement"></div>
</button>

@code {
    private ElementReference rippleElement;

    /// <summary>
    /// Texto do botão
    /// </summary>
    [Parameter] public string? Text { get; set; }

    /// <summary>
    /// Ícone do botão (emoji ou texto)
    /// </summary>
    [Parameter] public string? Icon { get; set; }

    /// <summary>
    /// Variante visual do botão
    /// </summary>
    [Parameter] public SynQButtonVariant Variant { get; set; } = SynQButtonVariant.Primary;

    /// <summary>
    /// Tamanho do botão
    /// </summary>
    [Parameter] public SynQButtonSize Size { get; set; } = SynQButtonSize.Medium;

    /// <summary>
    /// Tipo do botão HTML
    /// </summary>
    [Parameter] public string Type { get; set; } = "button";

    /// <summary>
    /// Se o botão está desabilitado
    /// </summary>
    [Parameter] public bool IsDisabled { get; set; }

    /// <summary>
    /// Se o botão está em estado de carregamento
    /// </summary>
    [Parameter] public bool IsLoading { get; set; }

    /// <summary>
    /// Se deve parar a propagação do evento de click
    /// </summary>
    [Parameter] public bool StopPropagation { get; set; } = false;

    /// <summary>
    /// Callback para evento de click
    /// </summary>
    [Parameter] public EventCallback OnClick { get; set; }

    /// <summary>
    /// Conteúdo personalizado do botão
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Atributos HTML adicionais
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Manipula o evento de mouse down para efeito ripple
    /// </summary>
    private void OnMouseDown(MouseEventArgs e)
    {
        // TODO: Implementar ripple effect via JavaScript
        // Por enquanto, apenas adiciona classe CSS
        StateHasChanged();
    }

    /// <summary>
    /// Gera as classes CSS do botão baseado nos parâmetros
    /// </summary>
    private string GetButtonClasses()
    {
        var classes = new List<string> { "synq-btn", "synq-button-enhanced", "synq-ripple", "synq-focus-enhanced" };

        // Variante
        classes.Add(Variant switch
        {
            SynQButtonVariant.Primary => "synq-btn-primary",
            SynQButtonVariant.Secondary => "synq-btn-secondary",
            SynQButtonVariant.Outline => "synq-btn-outline",
            SynQButtonVariant.Ghost => "synq-btn-ghost",
            _ => "synq-btn-primary"
        });

        // Tamanho
        classes.Add(Size switch
        {
            SynQButtonSize.Small => "synq-btn-sm",
            SynQButtonSize.Large => "synq-btn-lg",
            _ => ""
        });

        // Estados
        if (IsLoading)
            classes.Add("synq-btn-loading");

        // Classes adicionais do usuário
        if (AdditionalAttributes?.ContainsKey("class") == true)
            classes.Add(AdditionalAttributes["class"].ToString()!);

        return string.Join(" ", classes.Where(c => !string.IsNullOrEmpty(c)));
    }
}

@* Estilos específicos do componente *@
<style>
    .synq-btn {
        position: relative;
        overflow: hidden;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .synq-btn:hover {
        transform: translateY(-1px);
    }

    .synq-btn:active {
        transform: translateY(0);
    }

    .synq-btn-loading {
        pointer-events: none;
        opacity: 0.7;
    }

    .synq-btn-icon {
        font-size: 1.1em;
        transition: transform 0.2s ease;
    }

    .synq-btn:hover .synq-btn-icon {
        transform: scale(1.1);
    }

    .synq-btn .synq-spinner {
        width: 1em;
        height: 1em;
        border-width: 1px;
    }

    .synq-btn-ripple {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        border-radius: inherit;
    }

    .synq-btn-ripple::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
    }

    .synq-btn:active .synq-btn-ripple::before {
        width: 300px;
        height: 300px;
    }

    /* Animação de carregamento melhorada */
    .synq-btn-loading .synq-spinner {
        animation: spin 1s linear infinite;
    }

    /* Estados de focus melhorados */
    .synq-btn:focus {
        outline: 2px solid var(--synq-primary);
        outline-offset: 2px;
    }

    /* Efeitos de hover específicos por variante */
    .synq-btn-primary:hover {
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .synq-btn-outline:hover {
        background: var(--synq-primary);
        color: white;
    }

    .synq-btn-ghost:hover {
        background: rgba(var(--synq-primary-rgb), 0.1);
    }
</style>
